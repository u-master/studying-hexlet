# Redux

Redux — это такая база данных в программе. Она хранит внутри себя состояние (то есть данные) приложения. 
Redux отвечает только за состояние и никак не связан с браузером, DOM и фронтендом в целом. 
Его можно использовать, самого по себе, даже на бекенде в Node.js.
Redux, с точки зрения кода — это объект, внутри которого лежат данные. 
Он используется остальными частями приложения для их хранения, изменения и извлечения. 
В терминологии Redux он называется **контейнер**, так как данные хранятся внутри.

### Три принципа

Что главное в Redux:

  1. Single source of truth — используя Redux, мы работаем только с одним контейнером на приложение. 
  Это одно из ключевых отличий от Flux-архитектуры. Всё состояние в одном месте.
  1. State is read-only — данные меняются только косвенно, используя функциональный стиль.
  1. Changes are made with pure functions — внутри хранилища можно использовать только чистые функции. 
  Тут правила даже строже чем во Flux, так как не позволяется использовать даже Date.now() и ему подобные функции, 
  которые хотя и не обладают побочными эффектами, но все же являются недетерминированными. 
  Все подобные вызовы должны делаться до вызова dispatch.

Ниже полный пример использования Redux:

    import { createStore } from 'redux';

    // Редьюсер – функция, которая описывает то, как изменяются данные внутри контейнера
    // Она принимает на вход текущее состояние приложения и должна вернуть новое
    // Именно так работает функция reduce, отсюда и название
    // Второй параметр описывает действие, с его помощью мы узнаем
    // как конкретно надо обновить данные для конкретного вызова
    // action — это объект, в котором обязательно есть поле type, содержащее имя действия
    // в этом же объекте прокидываются дополнительные данные. Для данных, которые передаются
    // как параметры, лучше использовать вложеный единый объект (например, action.payload).
    const reducer = (state = 0, action) => {
      switch (action.type) {
        case 'INCREMENT':
          return state + 1;
        case 'DECREMENT':
          return state - 1;
        default: // действие по умолчанию – возврат текущего состояния
          return state;
      }
    };

    // Создание контейнера на основе редьюсера
    // Именно в этом контейнере хранится состояние, которое возвращает редьюсер
    const store = createStore(reducer);

    // Состояние можно извлечь с помощью функции getState()
    store.getState(); // 0 – так как это начальное значение состояния

    // Функция subscribe позволяет подписываться на изменение состояния контейнера
    // Она очень похожа на addEventListener, но без указания события
    // Как только меняется любая часть состояния, контейнер по очереди вызывает все что было добавлено
    // Здесь мы просто извлекаем из контейнера состояние и печатаем его на экран
    store.subscribe(() => console.log(store.getState()));

    // dispatch – функция, которая вызывает редьюсер
    // передает туда текущее состояние
    // и действие (напомню что это объект со свойством type)

    // Редьюсер увеличивает состояние на единицу 
    store.dispatch({ type: 'INCREMENT' }); // => 1
    // Редьюсер увеличивает состояние на единицу 
    store.dispatch({ type: 'INCREMENT' }); // => 2
    // Редьюсер уменьшает состояние на единицу 
    store.dispatch({ type: 'DECREMENT' }); // => 1

    store.getState(); // 1

    // Для избежания дублирования и повышения уровня абстракции, вынесем действия в функции
    const increment = () => ({ type: 'INCREMENT' });
    const decrement = () => ({ type: 'DECREMENT' });

    store.dispatch(increment()); // => 2
    store.dispatch(decrement()); // => 1

## Начальное состояние

Начальное состояние задаётся в определении редьюсера:

    const reducer = (state = 0, action) { /* ... */ }

Но часто этого недостаточно. Данные могут прийти из бэкенда и их нужно прогрузить в контейнер перед началом работы. Для этого случая в Redux есть особый путь:

    const store = createStore(reducer, initState);

Redux посылает специальное действие (*@@redux/INIT*), которое нельзя перехватывать. 
Если редьюсер реализован правильно и **содержит секцию default в switch**, то контейнер заполнится данными из `initState`. 
В коде выше, функция `createStore` вызовет редьюсер так: `reducer(initState, '@@redux/INIT')`. Затем выполнится ветка `default` и состоянием контейнера станет число `initState`.
