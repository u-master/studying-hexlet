# Redux

Redux — это такая база данных в программе. Она хранит внутри себя состояние (то есть данные) приложения. 
Redux отвечает только за состояние и никак не связан с браузером, DOM и фронтендом в целом. 
Его можно использовать, самого по себе, даже на бекенде в Node.js.
Redux, с точки зрения кода — это объект, внутри которого лежат данные. 
Он используется остальными частями приложения для их хранения, изменения и извлечения. 
В терминологии Redux он называется **контейнер**, так как данные хранятся внутри.

### Три принципа

Что главное в Redux:

  1. Single source of truth — используя Redux, мы работаем только с одним контейнером на приложение. 
  Это одно из ключевых отличий от Flux-архитектуры. Всё состояние в одном месте.
  1. State is read-only — данные меняются только косвенно, используя функциональный стиль.
  1. Changes are made with pure functions — внутри хранилища можно использовать только чистые функции. 
  Тут правила даже строже чем во Flux, так как не позволяется использовать даже Date.now() и ему подобные функции, 
  которые хотя и не обладают побочными эффектами, но все же являются недетерминированными. 
  Все подобные вызовы должны делаться до вызова dispatch.

Ниже полный пример использования Redux:

    import { createStore } from 'redux';

    // Редьюсер – функция, которая описывает то, как изменяются данные внутри контейнера
    // Она принимает на вход текущее состояние приложения и должна вернуть новое
    // Именно так работает функция reduce, отсюда и название
    // Второй параметр описывает действие, с его помощью мы узнаем
    // как конкретно надо обновить данные для конкретного вызова
    // action — это объект, в котором обязательно есть поле type, содержащее имя действия
    // в этом же объекте прокидываются дополнительные данные. Для данных, которые передаются
    // как параметры, лучше использовать вложеный единый объект (например, action.payload).
    const reducer = (state = 0, action) => {
      switch (action.type) {
        case 'INCREMENT':
          return state + 1;
        case 'DECREMENT':
          return state - 1;
        default: // действие по умолчанию – возврат текущего состояния
          return state;
      }
    };

    // Создание контейнера на основе редьюсера
    // Именно в этом контейнере хранится состояние, которое возвращает редьюсер
    const store = createStore(reducer);

    // Состояние можно извлечь с помощью функции getState()
    store.getState(); // 0 – так как это начальное значение состояния

    // Функция subscribe позволяет подписываться на изменение состояния контейнера
    // Она очень похожа на addEventListener, но без указания события
    // Как только меняется любая часть состояния, контейнер по очереди вызывает все что было добавлено
    // Здесь мы просто извлекаем из контейнера состояние и печатаем его на экран
    store.subscribe(() => console.log(store.getState()));

    // dispatch – функция, которая вызывает редьюсер
    // передает туда текущее состояние
    // и действие (напомню что это объект со свойством type)

    // Редьюсер увеличивает состояние на единицу 
    store.dispatch({ type: 'INCREMENT' }); // => 1
    // Редьюсер увеличивает состояние на единицу 
    store.dispatch({ type: 'INCREMENT' }); // => 2
    // Редьюсер уменьшает состояние на единицу 
    store.dispatch({ type: 'DECREMENT' }); // => 1

    store.getState(); // 1

    // Для избежания дублирования и повышения уровня абстракции, вынесем действия в функции
    const increment = () => ({ type: 'INCREMENT' });
    const decrement = () => ({ type: 'DECREMENT' });

    store.dispatch(increment()); // => 2
    store.dispatch(decrement()); // => 1

## Состояние

Все, что хранится в контейнере, мы называем состоянием, но не все состояния одинаково полезны. Вот какую классификацию вводит документация Redux:

  * Domain data — данные приложения, которые нужно отображать, использовать и модифицировать. Например, список пользователей, загруженный с сервера.
  * App state — данные, определяющие поведение приложения. Например, текущий открытый URL.
  * UI state — данные, определяющие то, как выглядит UI. Например, вывод списка в плиточном виде.

Структура состояния должна напоминать базу данных. Всё максимально плоско и нормализованно.


## Начальное состояние

Начальное состояние задаётся в определении редьюсера:

    const reducer = (state = 0, action) { /* ... */ }

Но часто этого недостаточно. Данные могут прийти из бэкенда и их нужно прогрузить в контейнер перед началом работы. Для этого случая в Redux есть особый путь:

    const store = createStore(reducer, initState);

Redux посылает специальное действие (*@@redux/INIT*), которое нельзя перехватывать. 
Если редьюсер реализован правильно и **содержит секцию default в switch**, то контейнер заполнится данными из `initState`. 
В коде выше, функция `createStore` вызовет редьюсер так: `reducer(initState, '@@redux/INIT')`. Затем выполнится ветка `default` и состоянием контейнера станет число `initState`.

## Комбинирование редьюсеров

С ростом количества сущностей (состояний), редьюсер становится очень тяжёлым. Огромный кусок кода, который делает всё.
Для решения этой проблемы, Redux имеет встроенный механизм, позволяющий создавать множественные редьюсеры и комбинировать их друг с другом.
Работает это так: для каждого свойства верхнего уровня пишется свой собственный редьюсер, а затем они с помощью функции `combineReducers` объединяются в корневой редьюсер, который уже используется для создания контейнера.

    {
      todos: [
        { id: 1, name: 'why?' },
        { id: 3, name: 'who?' },
      ],
      comments: [
        { id: 23, todoId: 3, text: 'great!' },
      ],
    }

    import { combineReducers, createStore } from 'redux';

    const todosReducer = (state = [], action) => {
      // сюда попадут данные из todos
    };

    const commentsReducer = (state = [], action) => {
      // сюда попадут данные из comments
    };

    const rootReducer = combineReducers({
      todos: todosReducer,
      comments: commentsReducer,
    });
    const store = createStore(rootReducer);
    
В каждый редьюсер приходит state, но это не всё состояние контейнера, а только та часть, которая лежит в соответствующем свойстве.

Редьюсеры могут быть даже вложенными и для этого не нужны никакие специальные средства, обычные функции, принимающие на вход данные и возвращающие новые данные.
С таким подходом появляется одна особенность, которая вначале может испугать. Так как каждый редьюсер имеет доступ только к своей части состояния, действия, порождающие изменения сразу в нескольких местах, будут повторяться в разных редьюсерах.

    const todos = (state = {}, action) => {
      switch (action.type) {
        case 'TODO_REMOVE':
          // ...
      }
    };

    const comments = (state = {}, action) => {
      switch (action.type) {
        // При удалении ToDo также нужно удалить все его комментарии
        case 'TODO_REMOVE':
          // ...
      }
    };

