## create-react-app

Экосистема для старта фронтенд-проектов. Это npm-библиотека, которая позволяет стартануть с нулевой конфигурацией.

    npx create-react-app my-app
    cd my-app/
    npm start

Дальше просто открывайте localhost:3000 и наслаждайтесь.

## babel-preset-react

React расширяет JS и не может работать с Babel без этого пресета.
Не забудьте подключить пресет (preset) babel-preset-react к вашей конфигурации Babel. 
Для `create-react-app` пресет не нужен!

## React Developer Tools

Это расширение для браузера, которое даёт очень удобную панель для анализа происходящего с React в вашем приложении. 

# Импорты

Для работы с React нужно две библиотеки: сам `React` и `ReactDOM`. Причина наличия двух зависимостей достаточно проста. 
Сама библиотека React не связана с DOM напрямую и используется не только в браузере. Поэтому отрисовка конкретно для DOM вынесена в отдельный пакет ReactDOM.

    import React from 'react';
    import ReactDOM from 'react-dom';
    
Важно, чтобы React был импортирован именно как React: `import React from 'react'`.
    
# Компоненты

Центральное понятие в React, единственная сущность, которую он содержит. Вся остальная функциональность построена вокруг компонентов.

    export default class Hello extends React.Component {
      render() {
        return <div>Hello</div>;
      }
    }

  1. Компонент React – это класс, который наследуется от класса `React.Component` (как мы увидим позже, это не единственный способ создать компонент).
  
  1. Функция `render` возвращает то, что будет отрисовано в браузере. Класс-компонент *без функции render существовать не может*, это его интерфейс.
  
  1. Самое поразительное происходит в этой строчке: `return <div>Hello</div>;`. Здравый смысл подсказывает, что такая запись синтаксически невозможна в JS. То, что вы видите, называется **JSX** и является расширением языка (добавляется с помощью Babel). 
  
  1. Экспорт класса по умолчанию задан неспроста. В JS принято создавать один класс на файл. В отличие от обычных классов, *React-компоненты имеют расширение языка JSX*, а значит компонент, определённый выше, должен лежать в файле с именем `Hello.jsx`. Вообще говоря, для всех файлов, которые содержат `JSX`, *принято давать расширение `.jsx`*, независимо от того, создаётся ли компонент в этом файле или нет.

  1. Обратите внимание: класс всё равно проименован. Мы действительно можем его не именовать, но тогда через расширение React Dev Tools будет тяжело понять, что же отрисовал React, так как любой безымянный компонент отображается как `<ReactComponent>`. Поэтому возьмём себе за правило *всегда давать компонентам имена*.

  1. Главное запомнить то, что *в конечном итоге любой React-компонент возвращает кусок DOM* (на самом деле – виртуальный DOM).
  
  1. div – это тоже компонент React, только встроенный. Отличить встроенные компоненты от самописных очень легко. Встроенные всегда начинаются с маленькой буквы, а те, которые не являются частью React, *должны начинаться с большой буквы*.

  1. Созданный компонент сам по себе ничего не делает. Чтобы насладиться результатом его работы, нужно произвести так называемое **монтирование**. То есть указать React, куда его вставить в DOM.
  
         const mountNode = document.getElementById('react-root');
         ReactDOM.render(<Hello />, mountNode);

     Первым параметром передаётся наш компонент *в синтаксисе JSX*, а вторым - реальный узел, любой узел внутри body. Как правило, если у нас не SPA, то React используется в виде виджетов, подключаемых на странице в разных местах. На одной странице может быть несколько виджетов.
  
# JSX

JSX – это похожее на XML-разметку расширение для JavaScript, созданное специально для задач React. React из коробки поставляется с набором компонентов, которые полностью повторяют HTML. По большей части синтаксис и структура JSX и HTML совпадают, но есть некоторые важные различия:

  1. Так как это похожий на XML синтаксис, одиночные теги в JSX должны быть закрыты: `<hr />`.
  1. Вместо атрибута class в JSX используется имя свойства в DOM: className.
  1. В JSX все свойства DOM и атрибуты (включая обработчики событий) должны быть записаны в camelCase. Исключением являются атрибуты aria- и data-.
  1. Так как for — зарезервированное слово в JS, в React-элементах используется свойство htmlFor.
  1. Так как class — зарезервированное слово в JS, в React-элементах используется свойство className.
  1. Если атрибут передаётся в компонент без значения, то оно автоматически становится равным true.
  1. Совсем по другому работает атрибут style. Если в HTML это обычная строка, то в JSX только объект.
  1. Для консистентности с именами атрибутов в HTML, имена CSS-свойств также должны быть записаны в стиле camelCase.

Так же как и в HTML, из компонентов можно строить композиции (в том числе и из других компонентов), например такую:

    const vdom = (
      <div className="card">
        <div className="card-body">
          <h4 className="card-title">Card title</h4>
          <p className="card-text">my text</p>
          <a href="#" className="btn btn-primary">Go somewhere</a>
        </div>
      </div>
    );

И это всё валидный код на JS *с подключённым расширением для JSX*. Нужно помнить, что JSX – расширение языка, а значит это именно код, а не html.
То, что каждый компонент React возвращает кусок DOM, является следствием его фундаментальной идеи и архитектуры.

Внутри JSX можно делать интерполяцию любого JS выражения (не инструкции), в которое также можно вкладывать JSX:

    const name = 'Eva';
    
    const vdom1 = <div>Hello, {name}</div>;
    const vdom2 = <div>Hello, {name.repeat(3)}</div>;

В реальной практике возникают ситуации, когда наличие компонента в DOM зависит от некоторых условий. Например, если в компонент не передали текст, то и не надо выводить соответствующий кусок. Пример:

    const vdom = (
      <div>
        {text ? <h1>{text}</h1> : null}
        <Hello />
      </div>
    );
    
То есть **null** – это допустимое значение, которое рассматривается React как *пустой компонент*. Точно также интерпретируются **false**, **true** и **undefined**. Поэтому пример выше можно переписать ещё короче.

    const vdom = (
      <div>
        {text && <h1>{text}</h1>}
        <Hello />
      </div>
    );

Комментарии JSX не поддерживает напрямую, но их можно эмулировать, используя JavaScript. Для этого достаточно вставить блок кода, внутри которого однострочный JavaScript комментарий:

    {/* A JSX comment */}
    
 Обычный HTML не очень безопасен. Любой текст, который должен оставаться текстом, необходимо экранировать перед выводом. Иначе если внутри содержится HTML, то он будет проинтерпретирован. JSX работает по-другому. Всё, что выводится обычным способом - безопасно по умолчанию и экранируется автоматически. А вот в тех местах, где этого не требуется, экранирование отключается. По сути, для вывода без экранирования нужно использовать свойство *dangerouslySetInnerHTML*.
 
     class Component extends React.Component {
      createMarkup () {
        return { __html: 'First &middot; Second' };
      }

      render() {
        return <div dangerouslySetInnerHTML={this.createMarkup()} />;
      }
    }
    
Стили передаются объектом, имена CSS-свойств должны быть записаны в *camelCase*:

    class Component extends React.Component {
      render() {
        const divStyle = {
          color: 'blue',
          fontSize: '50px',
        };

        return <div style={divStyle}>Hello World!</div>;
      }
    }


# Props

Передавать данные в компоненты можно с помощью **пропсов** (props). Снаружи пропсы передаются *как атрибуты в HTML*, которые внутри компонента доступны из объекта `props`. Встроенные компоненты точно так же принимают на вход пропсы (например, `className` и другие).

    class HelloMessage extends React.Component {
        render() {
            return <div>Hello {this.props.name}</div>;
        }
    }
    
    const vdom = (
      <div className="row">
        <div className="col">
          <HelloMessage name="Kate" />
        </div>
      </div>
    );

Главное, что нужно запомнить при работе с пропсами: **их нельзя изменять**. Во-первых, из-за принципа работы React это просто ни к чему не приведёт, во-вторых, для работы с изменяемым состоянием в React предусмотрен совершенно другой механизм.

Работая с пропсами, нередко приходится передавать множество параметров, либо эти параметры присутствуют в коде в виде объекта. В таком случае можно упростить передачу, используя оператор расширения.

    const params = {
      className: 'row',
      title: 'name',
    };
    const name = 'Eva';
    const vdom = <div id="container" {...params}>
      Hello, {name}
    </div>;
    
В React предусмотрен способ устанавливать значения пропсов по умолчанию. Пример:

    class Header extends React.Component {
      static defaultProps = {
        text: 'Hello, world!',
      };
    
      render() {
        return (
          <h1>{this.props.text}</h1>
        );
      }
    }

В работе *с коллекциями элементов* в JSX по большей части нет ничего особенного.   
Для повышения эффективности, React настоятельно рекомендует идентифицировать каждую генерируемую строку коллекции. *Генерируя коллекцию элементов в JSX, нужно обязательно проставлять уникальный проп `key`*, который не меняется при повторной генерации коллекции. Если не указать `key` в коллекции, то React начнёт выбрасывать предупреждения об этом в консоль браузера. Кстати, `key` не обрабатывается как обычный проп и его нельзя получить внутри компонента как `this.props.key`.

    class List extends React.Component {
      render() {
        const { data } = this.props
        return (
          <ul>
            {data.map((item) => <li key={item.id}>{item.name}</li>)}
          </ul>
        );
      }
    }

    const items = [
      { id: 'first-item', name: 'first' },
      { id: 'second-item', name: 'second' }
    ];

    ReactDOM.render(
      <List data={items} />,
      document.getElementById('react-root'),
    );

Раньше это было не так, но сейчас допустимо из компонента возвращать массив компонентов. React сам правильно вставит их в DOM:

    class List extends React.Component {
      render() {
        const { data } = this.props;
        const f = (item) => <div key={item.id}>{item.name}</div>;
        return data.map(f);
      }
    }

Для *ручного формирования массива компонентов из корневого компонента*, в React ввели специальный компонент `<React.Fragment>`, которым *можно оборачивать любую коллекцию элементов*. Его особенность в том, что этот элемент никак не отражается в реальном DOM, а существует только на уровне JSX.

    class Article extends React.Component {
      render() {
        const { header, body } = this.props;
        return (
          <React.Fragment>
            <h1>{header}</h1>
            <div>{body}</div>
          </React.Fragment>
        );
      }
    }

У `<React.Fragment>` есть короткая версия `<>`.

    return (
      <>
        <h1>{header}</h1>
        <div>{body}</div>
      </>
    );
    
## Пропс children. React.Children. Вложенные компоненты.

Мы можем оперировать иерархическими структурами при помощи пропса `children`.

    class Alert extends React.Component {
      render() {
        const { children } = this.props;
        return (<div className="alert alert-primary">
          {children}
        </div>);
      }
    }
    
    const vdom = <Alert>
      <p>Message text 1</p>
      <hr />
      <p class="mb-0">Message text 2</p>
    </Alert>;
    
Теперь компонент в JSX пишется в парном теге `<Alert> </Alert>`. Все, что находится между открывающим и закрывающим тегом, попадает внутрь пропса children.
**Но**: *тип у `children` зависит от содержимого*! В случае, когда тег используется как одиночный (<div />), свойство будет равно `undefined`. Если этим содержимым является строка, то именно она окажется внутри `children`, правда, после некоторой обработки: JSX удаляет пробельные символы с начала и конца строки, переносы строки. Любой одиночный дочерний компонент также будет представлен сам собой в `children`. Во всех остальных случаях `children` будет содержать массив. Особенно опасно использовать `children.length`, т.к. в зависимости от типа результат будет *длина строки* или *длина массива вложеных элементов*.

React предоставляет набор функций, предназначенных для манипулирования пропсом `children`. Все они доступны в **React.Children**.

  * React.Children.count

        class ChildrenCounter extends React.Component {
          render() {
            const { children } = this.props
            return <p>Count: {React.Children.count(children)}</p>
          }
        }

  * React.Children.map
  
        class IgnoreFirstChild extends React.Component {
          render() {
            const { children } = this.props;
            return (<div>
                {React.Children.map(children, (child, i) => {
                  // Ignore the first child
                  if (i < 1) return
                  return child
                })}
              </div>);
          }
        }

Кроме перечисленного выше, бывает необходимо обработать дочерние элементы перед выводом, изменив часть в пропсе. Конечно же, напрямую этого сделать нельзя, ведь *пропсы неизменяемы*. Такого поведения можно добиться, клонируя элементы функцией **React.cloneElement**.

## Пакет classnames

Для управления набором классов для компонента, React рекомендует использовать пакет `classnames`. Принцип его работы прост: вместо манипулирования строчкой напрямую, нужно сформировать правильный объект, который уже будет преобразован в строку.

    import cn from 'classnames'
    
    class Button extends React.Component {
      render () {
        const { isPressed, isHovered, label } = this.props;
        const buttonType = 'primary';
        const btnClass = cn({
          btn: true,
          'btn-pressed': isPressed,
          'btn-over': !isPressed && isHovered,
          [`btn-${buttonType}`]: true,
        });
        return <button className={btnClass}>{label}</button>;
      }
    };
    
## Функциональные компоненты

Для создания компонентов React не обязательно использовать классы.

    const List = (props) => {
      return (<ul>
        {props.items.map(v => <li>{v}</li>)}
      </ul>);
    }

    ReactDOM.render(
      <List items={[1, 2, 3]} />,
      document.getElementById('react-root'),
    );

Компоненты, созданные как функции, называются **функциональными**. Они принимают объект со свойствами как первый аргумент, и также начинаются с большой буквы.
На вопрос "когда их стоит использовать?" ответ очень простой. Всегда, *когда компонент не хранит в себе состояние*. Другими словами, большинство компонентов в проекте должно быть именно функциональными.

## Virtual Dom

  1. Действия пользователя приводят к изменению состояния приложения (через setState).
  1. React запускает цикл отрисовки. Начиная от того компонента, в котором было изменено состояние (как правило, корневой компонент), через пропсы данные постепенно распространяются от компонентов более высокого уровня до самых глубинных компонентов.
  1. Получившийся html интегрируется в страницу.
  
Те, кто хорошо знаком с функциональным подходом, могут увидеть прямую связь. React действительно делает мир неизменяемым (immutable). Самый простой способ реализовать подобное поведение - использовать mountElement.innerHTML, который заменяет html целиком после вызова setState. Главная проблема при использовании innerHTML связана с производительностью. Сказать, что это медленно — ничего не сказать. Поэтому создатели React пошли другим путём.

В реальности после того, как отработает рендеринг (вызов функции render для всего дерева компонентов), создаётся так называемый виртуальный DOM (virtual DOM). Это просто JS-объект определённой структуры, который отражает состояние экрана. Далее React сравнивает новое дерево виртуального DOM со старым и строит разницу между ними. И только в этот момент начинается отрисовка нового состояния в реальный DOM. React вносит изменения в реальный DOM настолько эффективно, насколько это возможно, ведь он знает КАК его надо изменить. 

Создатели React называют этот подход *one-way data flow* (Распространение изменений идёт в одну сторону. Меняются данные в состоянии, перерисовывается приложение).
    
# События и состояния

Компоненты, приведенные выше, были `stateless`, то есть не содержали никакого состояния и могли только отрисовывать переданные свойства. Компоненты также могут быть `stateful`, то есть сохранять внутри себя состояние и обрабатывать его изменения.

  1. Внутри компонента, в конструкторе, определяется начальное состояние, с которым будет инициализирован компонент после отрисовки. Единственное требование к состоянию, которое предъявляет React - тип данных: он должен быть объектом. То, что хранится внутри, определяется самим приложением. Конструктор - единственное место, где `state` может изменяться напрямую (точнее, создаваться). Во всех остальных местах *`this.state` должен использоваться только для чтения*!
  
         class Component extends React.Component {
           constructor(props) {
            super(props); // всегда обязательно
            this.state = { count: 0 };
           }
         }

  1. Функция render использует данные из state для отрисовки.
  
         render() {
           return <button onClick={this.onClick}>
             count: {this.state.count}
           </button>;
         }

  1. На кнопку вешается обработчик. В отличие от HTML, в свойство onClick передается функция и она вызовется автоматически в момент срабатывания события. Внутри обработчика читается текущее значение счетчика, к нему прибавляется единица и далее идет установка нового состояния. Повторюсь: *крайне важно не изменять state напрямую*. *Для установки нового состояния в React предусмотрена функция setState. Именно её вызов приводит к тому, что компонент, в конце концов, перерисуется.* Происходит это не сразу, то есть setState работает асинхронно и внутренняя магия пытается оптимизировать процесс рисования. Важный момент, что *в качестве обработчика должна использоваться стрелочная функция*. Первая причина заключается в том, что обработчики вызываются асинхронно, а методы в классах — это обычные функции с поздним связыванием. Поэтому мы не можем просто так повесить обработчик, так как он потеряет `this`. С таким определением придется постоянно писать подобный код: `onClick={this.onClick.bind(this)}` либо такой `onClick={() => this.onClick()}`. Вторая причина связана с производительностью. Оба предыдущих примера передачи обработчика порождают при каждом вызове функции `render` новые обработчики (так как функции сравниваются по ссылкам, а не по содержимому), а для React это критично. 
  
         onClick = () => {
           const { count } = this.state;
           this.setState({ count: count + 1 });
         };
         
Изменять state в обработчиках только через функцию `setState()`. В параметрах указывается объект с теми значениями стейтов, которые меняются, а те которые не будут указаны - останутся без изменений. `this.setState({ primary: !primary });` 

Еще рекомендация, которую дают разработчики React, это делать структуру стейтов максимально плоской, похожей на то, как мы храним данные в базе данных. Причём желательно в хорошо нормализованном виде. Другими словами, не нужно дублировать данные в состоянии. Пример того как правильно это делать:

    const state = {
      articles: [/*...*/],
      comments: [/*...*/],
    }
    
Один из самых частых вопросов у тех, кто только начинает знакомиться с React, связан с тем, как распределять состояние по компонентам. Короткий ответ: никак. Почти во всех ситуациях разделение состояния усложнит код и работу с ним. Правильный подход — создать корневой компонент, который содержит всё состояние внутри себя, а все нижележащие компоненты получают свои данные как пропсы. В частности, поэтому состояние должно быть максимально плоским, как реляционная база данных. Тогда можно спокойно применять нормализацию и безболезненно выполнять обновления.

Иногда могут возникать ситуации, когда необходимые в глубине свойства приходится протаскивать сквозь множество промежуточных компонентов, которые сами эти пропсы не используют. Это ещё одна причина стараться не увлекаться глубокой вложенностью. С другой стороны, Redux во многом решает эту проблему (и много других). Из этого возникает ещё одна сложность: что, если событие возникает в глубинном компоненте, у которого нет своего состояния? Без использования Redux, по сути, только один выход. Корневой компонент должен пробрасывать *колбеки* во внутренние компоненты, а те, в свою очередь, пробрасывают их дальше по необходимости.

         
## Инициализация состояния компоненты

Предположим, что в компоненте, нужно задать первоначальное значение состояния снаружи, и только в его отсутствие использовать значение по-умолчанию.

  1. Прокидываем через пропс значение (либо не указываем - тогда подразумевается значение по-умолчанию).

         const vdom = <div>
           <Counter count={5} />
           <Counter />
         </div>;

  1. Установить значения по-умолчанию в defaultProps, в конструкторе записать в state проброшенное через пропс значение:
  
         static defaultProps = {
           count: 0,
         };
         
         constructor(props) {
           super(props);
           this.state = { count: this.props.count }
         }

## События

В любой обработчик события при вызове передаётся объект типа SyntheticEvent, кроссбраузерный "враппер" (обёртка) над нативным объектом события. Интерфейсно он не отличается от нативного, кроме того, что работает одинаково во всех браузерах. Все также работает `preventDefault` и `stopPropagation`.

    onClick = (e) => {
      e.preventDefault();
      this.setState({ count: this.state.count + 1 });
    };

React нормализует события так, что они имеют консистентные свойства в различных браузерах. Кроме того, в формах добавляется событие `onChange`, которое ведёт себя в соответствии со своим названием и сильно упрощает работу.

## Формы

В отличие от прямой работы с DOM, в React источником данных является состояние. Формы не являются исключением. Любое изменение в форме, посимвольно, если это ввод, должно быть перенесено в состояние. А элементы форм, чьи данные хранятся в состоянии React, называются управляемые компоненты (controlled components).

    class TextInput extends React.Component {
      constructor(props) {
        super(props);
        this.state = { text: this.props.text };
      }

      handleSubmit = (e) => {
        e.preventDefault();
        alert(`A name was submitted: ${this.state.text}`);
      };

      handleChange = (e) => {
        this.setState({ text: e.target.value });
      };

      render() {
        return <form onSubmit={this.handleSubmit}>
          <input onChange={this.handleChange} value={this.state.text} />
          <input type='submit' value='Submit' />
        </form>;
      }
    }

### `<textarea>`

В HTML значение `<textarea>` устанавливается как его содержимое:

    <textarea>
      Like this
    </textarea>

В React для этого используется атрибут `value`:

    onChange = (e) => {
      this.setState({ text: e.target.value });
    };
    render() {
      return <textarea onChange={this.onChange} value={this.state.text} />;
    }
    
Стоит отметить, что событие `onChange` в React работает так, как ожидается, в отличие от `onChange` в HTML, который срабатывает только когда элемент теряет фокус. Поэтому мы гарантировано получаем срабатывание события на каждое изменение. При этом данные из элемента формы извлекаются обычным способом через `e.target.value`. Ну а дальше всё по старой схеме — данные обновляются в состоянии.

### Выпадающий список

В HTML текущий элемент выбирается с помощью атрибута `selected`, проставленного на нужном `option`. React предлагает другой, более простой и удобный способ. Достаточно проставить атрибут `value` компонента `select` в нужное значение. 

    class FlavorForm extends React.Component {
      constructor(props) {
        super(props);
        this.state = { value: '' };
      }

      handleChange = (e) => {
        this.setState({ value: e.target.value });
      };

      handleSubmit = (e) => {
        e.preventDefault();
        alert(`Your favorite flavor is: ${this.state.value}`);
      };

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Pick your favorite La Croix flavor:
              <select value={this.state.value} onChange={this.handleChange}>
                <option value="grapefruit">Grapefruit</option>
                <option value="lime">Lime</option>
                <option value="coconut">Coconut</option>
                <option value="mango">Mango</option>
              </select>
            </label>
            <input type="submit" value="Submit" />
          </form>
        );
      }
    }
    
### Чекбокс и радиокнопка

Оба этих типа поддерживают атрибут `checked`. Если он выставлен, то элемент отмечается выбранным.

    <input name="isGoing" type="checkbox" checked={this.state.isGoing} onChange={this.handleInputChange} />


# Пространства имён

    <Card>
      <CardBody>
        <CardTitle>Title</CardTitle>
        <b>Body</b>
      </CardBody>
    </Card>

Можно реализовать в виде такой структуры:

    <Card>
      <Card.Body>
        <Card.Title>Title</Card.Title>
        <b>Body</b>
      </Card.Body>
    </Card>

JSX поддерживает механизм пространств имён. Он довольно удобен. Во-первых, достаточно импортировать только компонент верхнего уровня, а остальное доступно уже через него, что довольно логично, если смотреть на JSX как на JS-код. Во-вторых, так лучше задаётся семантика.

Реализуется подобный механизм через статические свойства.

    const Title = (props) => <div className="card-title">{props.children}</div>;
    const Body = (props) => <div className="card-body">{props.children}</div>;

    class Card extends React.Component {
      static Body = Body;
      static Title = Title;

      render() {
        return <div className="card card-block">{this.props.children}</div>;
      }
    }
    
    const vdom = (
      <Card>
        <Card.Body>
          <Card.Title>What is love?</Card.Title>
        </Card.Body>
      </Card>);
      
# Жизненный цикл компонента

Каждый компонент React проходит несколько стадий в процессе своей жизни: он создаётся, затем добавляется в DOM, получает пропсы, и, наконец, удаляется из дерева. Этот процесс называют жизненным циклом компонента (**Component Lifecycle**). React предоставляет набор методов, которые позволяют встроиться в этот процесс. Например, метод *componentDidMount*  - он вызывается сразу _после_ отрисовки компонента. Происходит это ровно один раз. А метод *componentWillUnmount* выполняется прямо _перед_ удалением компонента из DOM.

    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = { date: new Date() };
      }

      componentDidMount() {
        this.timerId = setInterval(() => this.setState({ date: new Date() }), 1000);
      }

      componentWillUnmount() {
        clearInterval(this.timerId);
      }

      render() {
        const { date } = this.state;
        return (
          <div>{date.toLocaleTimeString()}</div>
        );
      }
    }

Мы рассмотрели два метода, позволяющих встраиваться в жизненный цикл компонента, но их значительно больше. Они делятся на три независимые группы:

  * *Монтирование* (*Mounting*). Эти методы вызываются во время создания объекта и вставки его в DOM.

    * constructor()
    * static getDerivedStateFromProps()
    * render()
    * componentDidMount()

  * *Обновление* (*Updating*) - может происходить при изменении свойств или состояния. Эти методы вызываются во время перерисовки.

    * static getDerivedStateFromProps()
    * shouldComponentUpdate()
    * render()
    * getSnapshotBeforeUpdate()
    * componentDidUpdate()

  * *Удаление* или *демонтирование* (*Unmount*). В эту группу входит один метод. Он вызывается во время удаления компонента из DOM.

    * componentWillUnmount()

# Библиотека [Redux Forms](https://redux-form.com/)

Работа с формами в React настоящая головная боль. Каждый новый элемент требует синхронизации с состоянием и написанием дополнительного кода на всех уровнях.
Этого можно избежать, подключив библиотеку наподобие `redux-form`. Документация этого пакета поистине огромна. Множество вариантов использования и способов кастомизации. Чтобы не сойти с ума, мы рассмотрим только базовые возможности этой библиотеки.

Как подключить *Redux Form*:

  1. Автоматизация синхронизации с контейнером подразумевает наличие специального редьюсера:
  
         import { reducer as formReducer } from 'redux-form';
         
         export default combineReducers({
           // По умолчанию свойство должно называться form
           form: formReducer,
           /* ... */
         });

  1. Теперь под каждую форму нужно выделять отдельный компонент и оборачивать его в компонент ReduxForm.
  
         import { reduxForm } from 'redux-form';
         
         class NewTaskForm extends React.Component {
           // ...
         }
         
         export default reduxForm({
           form: 'newTask',
         })(NewTaskForm);

     Обратите внимание на свойство `form`, оно задаёт имя ключа, под которым данные текущей формы будут храниться в Redux.
     
  1. Вместо использования стандартных компонентов React для элементов формы, *Redux Form поставляется со своими механизмами*. Потребность вполне понятная, иначе не сделать автоматическую синхронизацию. Эта часть Redux Form очень сильно кастомизируется. За подробностями прошу в официальную документацию.
  
         import  { Field } from 'redux-form';
         
         // ...
         
         render() {
           return <form className="form-inline">
             <div className="form-group mx-3">
               <Field name="text" required component="input" type="text" />
             </div>
             <button type="submit" className="btn btn-primary btn-sm">Add</button>
           </form>;
         }

  1. Остался последний шаг — отправка формы и работа с её данными.
  
         class NewTaskForm extends React.Component {
           addTask = (values) => {
             this.props.addTask({ task: values });
           }
           
           render() {
             return <form onSubmit={this.props.handleSubmit(this.addTask)}>
               {/* ... */}
               <button type="submit" className="btn btn-primary btn-sm">Add</button>
             </form>;
           }
         }
         
     Redux Form прокидывает в формы целую россыпь различных свойств. Главное из них — функция **`handleSubmit`**. Её необходимо вызвать на `onSubmit` формы, передав туда свой собственный обработчик. После отправки формы *в этот обработчик попадут все значения из формы в виде объекта*, где свойство — это *имя* элемента формы.

Теперь расширение и изменение любой формы станет настоящим праздником. Достаточно изменить саму форму и волшебным образом в обработчик начнут приходить новые данные.

А дальше начинаются нюансы:

  * Как очистить форму после отправки? В обработчике отправки можно вызывать функцию `this.props.reset()` и форма будет сброшена в первоначальный вид.
  * Как задать параметры по умолчанию? Достаточно передать в компонент пропс `initialValues`.

# Асинхронные действия

С точки зрения нашего React-Redux приложения автомат будет состоять из состояния в контейнере и трёх событий:

  * TASK_UPDATE_REQUEST.
  * TASK_UPDATE_SUCCESS.
  * TASK_UPDATE_FAILURE.

Именование в стиле request, success и failure — рекомендация самого Redux. Желательно всегда придерживаться именно её в случаях, когда состояния три. Большинство запросов укладываются именно в эту схему. Описываем действия:

    export const updateTaskRequest = createAction('TASK_UPDATE_REQUEST');
    export const updateTaskSuccess = createAction('TASK_UPDATE_SUCCESS');
    export const updateTaskFailure = createAction('TASK_UPDATE_FAILURE');

Действия, описанные выше, по сути, синхронны. А где тогда выполняется сам запрос?

Для этого вводится понятие **асинхронные действия** (**async actions**). И если в React для работы с асинхронными вызовами ничего дополнительно делать не нужно, то Redux из коробки это не умеет. Наиболее простой способ начать выполнять запросы на сервер — подключить библиотеку **`redux-thunk`**. Она представляет из себя *мидлвар, который нужно не забыть подключить*:

    import thunk from 'redux-thunk';
    
    const store = createStore(
        reducers,
        /* ... */,
        applyMiddleware(thunk),
    );

На этом интеграция заканчивается. Следующим шагом создаются сами действия:

    export const updateTask = (id, values) => async (dispatch) => {
      dispatch(updateTaskRequest());
      try {
        const response = await axios.patch(routes.taskUrl(id), { task: values });
        dispatch(updateTaskSuccess({ task: response.data }));
      } catch (e) {
        // Обязательно выводите ошибку, иначе вы не узнаете что пошло не так при отладке
        console.log(e);
        dispatch(updateTaskFailure());
      }
    };

В отличие от синхронных действий, асинхронное — функция, даже две функции. Внешняя функция принимает те параметры, которые нам нужны, а вот внутренняя, асинхронная, принимает на вход функцию dispatch. Кстати, эту внутреннюю функцию вызывать не придётся, вся грязная работа делается автоматически за счёт проброса действий через контейнер. Работа этого действия для нашей ситуации описывается так (вообще этот паттерн встречается в реальных приложениях крайне часто):

  * Уведомляем Redux о начале внешнего запроса.
  * Выполняем внешний запрос.
  * Если запрос выполнился удачно, уведомляем Redux и передаём туда полученные данные (если есть).
  * Если запрос выполнился неудачно, уведомляем Redux.

Посмотрим, как в коде React вызывается обработчик, выполняющий наше действие:

    class EditTaskForm extends React.Component {
      handleUpdateTask = (values) => {
        const { updateTask, task } = this.props;
        updateTask(task.id, values);
      }

      render() {
        const { taskCreatingState } = this.props;
        const disabled = taskCreatingState === 'requested';

        return (
          <form action="" className="form-inline" onSubmit={this.props.handleSubmit(this.handleUpdateTask)}>
            <div className="form-group mx-3">
              <Field name="text" required component="input" type="text" />
            </div>
            <button type="submit" disabled={disabled} className="btn btn-primary btn-sm">Update</button>
          </form>
        );
      }
    }

    export default reduxForm({
      form: 'editTask',
    })(EditTaskForm);

Из кода выше видно, что действие вызывается как обычно.

Библиотека redux-thunk всего лишь один из многих способов работы с асинхронными действиями в Redux. Существуют и другие пакеты, дающие больший контроль и больший уровень автоматизации. Но, как правило, они сложнее в понимании.

# Тестирование

## jsdom

*jsdom* - реализация DOM API на чистом JS для использования в Node.js. Основной целью библиотеки является эмуляция подмножества функций браузера, достаточных для тестирования и парсинга сайтов. *jsdom* встроен в *jest* и не требует абсолютно никакой настройки. С точки зрения использования это выглядит так, что прямо в тесте у нас доступен document и window.

Возникает вопрос: зачем использовать jsdom, когда есть драйверы, работающие с настоящими браузерами. Ответов несколько:
  1. Скорость работы jsdom значительно выше, что не удивительно, ведь это просто библиотека на JS (к тому же, headless), в отличие от браузера.
  1. jsdom потребляет значительно меньше памяти для работы.
  1. Самое главное: jsdom и код нашего приложения работают в рамках одного интерпретатора Node.js. На практике это приводит к тому, что любые ошибки внутри кода приложения будут проявляться так, как мы бы этого и хотели, с возникновением исключения и отображением трассировки стека (стектрейса).

Единственный серьёзный недостаток (он же и плюс) заключается в том, что jsdom — это не браузер. Другими словами, тесты на jsdom могут вполне работать, а код в браузере нет, и наоборот. Кроме того, jsdom сильно отстаёт в развитии от тех же браузеров. Новые фичи в нем появляются сильно позже, да и старые работают не все. Во многом эта проблема нивелируется использованием полифилов, но если вы используете что-то уж совсем экзотическое, то, возможно, придётся отказаться. По своей практике скажу, что с этим всем можно жить и полифилы действительно спасают.

## react-test-renderer

Так как React генерирует виртуальный DOM, этим можно воспользоваться. Пакет react-test-renderer предоставляет возможность отрендерить компонент React без необходимости взаимодействия с браузером.

    import reactTestRenderer from 'react-test-renderer';

    const renderer = reactTestRenderer.create(
      <a href="https://www.facebook.com/">Facebook</a>
    );

    console.log(renderer.toJSON());
    // { type: 'a',
    //   props: { href: 'https://www.facebook.com/' },
    //   children: [ 'Facebook' ] }

С этим пакетом легко использовать снепшот-тестирование в Jest. Достаточно передать в expect результат вызова функции toJSON.

## Enzyme

Библиотека, разработанная программистами Airbnb для полноценного тестирования приложений на React.

