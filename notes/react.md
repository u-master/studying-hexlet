## create-react-app

Экосистема для старта фронтенд-проектов. Это npm-библиотека, которая позволяет стартануть с нулевой конфигурацией.

    npx create-react-app my-app
    cd my-app/
    npm start

Дальше просто открывайте localhost:3000 и наслаждайтесь.

## babel-preset-react

React расширяет JS и не может работать с Babel без этого пресета.
Не забудьте подключить пресет (preset) babel-preset-react к вашей конфигурации Babel. 
Для `create-react-app` пресет не нужен!

## React Developer Tools

Это расширение для браузера, которое даёт очень удобную панель для анализа происходящего с React в вашем приложении. 

# Импорты

Для работы с React нужно две библиотеки: сам `React` и `ReactDOM`. Причина наличия двух зависимостей достаточно проста. 
Сама библиотека React не связана с DOM напрямую и используется не только в браузере. Поэтому отрисовка конкретно для DOM вынесена в отдельный пакет ReactDOM.

    import React from 'react';
    import ReactDOM from 'react-dom';
    
Важно, чтобы React был импортирован именно как React: `import React from 'react'`.
    
# Компоненты

Центральное понятие в React, единственная сущность, которую он содержит. Вся остальная функциональность построена вокруг компонентов.

    export default class Hello extends React.Component {
      render() {
        return <div>Hello</div>;
      }
    }

  1. Компонент React – это класс, который наследуется от класса `React.Component` (как мы увидим позже, это не единственный способ создать компонент).
  
  1. Функция `render` возвращает то, что будет отрисовано в браузере. Класс-компонент *без функции render существовать не может*, это его интерфейс.
  
  1. Самое поразительное происходит в этой строчке: `return <div>Hello</div>;`. Здравый смысл подсказывает, что такая запись синтаксически невозможна в JS. То, что вы видите, называется **JSX** и является расширением языка (добавляется с помощью Babel). 
  
  1. Экспорт класса по умолчанию задан неспроста. В JS принято создавать один класс на файл. В отличие от обычных классов, *React-компоненты имеют расширение языка JSX*, а значит компонент, определённый выше, должен лежать в файле с именем `Hello.jsx`. Вообще говоря, для всех файлов, которые содержат `JSX`, *принято давать расширение `.jsx`*, независимо от того, создаётся ли компонент в этом файле или нет.

  1. Обратите внимание: класс всё равно проименован. Мы действительно можем его не именовать, но тогда через расширение React Dev Tools будет тяжело понять, что же отрисовал React, так как любой безымянный компонент отображается как `<ReactComponent>`. Поэтому возьмём себе за правило *всегда давать компонентам имена*.

  1. Главное запомнить то, что *в конечном итоге любой React-компонент возвращает кусок DOM* (на самом деле – виртуальный DOM).
  
  1. div – это тоже компонент React, только встроенный. Отличить встроенные компоненты от самописных очень легко. Встроенные всегда начинаются с маленькой буквы, а те, которые не являются частью React, *должны начинаться с большой буквы*.

  1. Созданный компонент сам по себе ничего не делает. Чтобы насладиться результатом его работы, нужно произвести так называемое **монтирование**. То есть указать React, куда его вставить в DOM.
  
         const mountNode = document.getElementById('react-root');
         ReactDOM.render(<Hello />, mountNode);

     Первым параметром передаётся наш компонент *в синтаксисе JSX*, а вторым - реальный узел, любой узел внутри body. Как правило, если у нас не SPA, то React используется в виде виджетов, подключаемых на странице в разных местах. На одной странице может быть несколько виджетов.
  
# JSX

JSX – это похожее на XML-разметку расширение для JavaScript, созданное специально для задач React. React из коробки поставляется с набором компонентов, которые полностью повторяют HTML. По большей части синтаксис и структура JSX и HTML совпадают, но есть некоторые важные различия:

  1. Так как это похожий на XML синтаксис, одиночные теги в JSX должны быть закрыты: `<hr />`.
  1. Вместо атрибута class в JSX используется имя свойства в DOM: className.
  1. В JSX все свойства DOM и атрибуты (включая обработчики событий) должны быть записаны в camelCase. Исключением являются атрибуты aria- и data-.
  1. Так как for — зарезервированное слово в JS, в React-элементах используется свойство htmlFor.
  1. Так как class — зарезервированное слово в JS, в React-элементах используется свойство className.
  1. Если атрибут передаётся в компонент без значения, то оно автоматически становится равным true.
  1. Совсем по другому работает атрибут style. Если в HTML это обычная строка, то в JSX только объект.
  1. Для консистентности с именами атрибутов в HTML, имена CSS-свойств также должны быть записаны в стиле camelCase.

Так же как и в HTML, из компонентов можно строить композиции (в том числе и из других компонентов), например такую:

    const vdom = (
      <div className="card">
        <div className="card-body">
          <h4 className="card-title">Card title</h4>
          <p className="card-text">my text</p>
          <a href="#" className="btn btn-primary">Go somewhere</a>
        </div>
      </div>
    );

И это всё валидный код на JS *с подключённым расширением для JSX*. Нужно помнить, что JSX – расширение языка, а значит это именно код, а не html.
То, что каждый компонент React возвращает кусок DOM, является следствием его фундаментальной идеи и архитектуры.

Внутри JSX можно делать интерполяцию любого JS выражения (не инструкции), в которое также можно вкладывать JSX:

    const name = 'Eva';
    
    const vdom1 = <div>Hello, {name}</div>;
    const vdom2 = <div>Hello, {name.repeat(3)}</div>;

В реальной практике возникают ситуации, когда наличие компонента в DOM зависит от некоторых условий. Например, если в компонент не передали текст, то и не надо выводить соответствующий кусок. Пример:

    const vdom = (
      <div>
        {text ? <h1>{text}</h1> : null}
        <Hello />
      </div>
    );
    
То есть **null** – это допустимое значение, которое рассматривается React как *пустой компонент*. Точно также интерпретируются **false**, **true** и **undefined**. Поэтому пример выше можно переписать ещё короче.

    const vdom = (
      <div>
        {text && <h1>{text}</h1>}
        <Hello />
      </div>
    );

Комментарии JSX не поддерживает напрямую, но их можно эмулировать, используя JavaScript. Для этого достаточно вставить блок кода, внутри которого однострочный JavaScript комментарий:

    {/* A JSX comment */}
    
 Обычный HTML не очень безопасен. Любой текст, который должен оставаться текстом, необходимо экранировать перед выводом. Иначе если внутри содержится HTML, то он будет проинтерпретирован. JSX работает по-другому. Всё, что выводится обычным способом - безопасно по умолчанию и экранируется автоматически. А вот в тех местах, где этого не требуется, экранирование отключается. По сути, для вывода без экранирования нужно использовать свойство *dangerouslySetInnerHTML*.
 
     class Component extends React.Component {
      createMarkup () {
        return { __html: 'First &middot; Second' };
      }

      render() {
        return <div dangerouslySetInnerHTML={this.createMarkup()} />;
      }
    }
    
Стили передаются объектом, имена CSS-свойств должны быть записаны в *camelCase*:

    class Component extends React.Component {
      render() {
        const divStyle = {
          color: 'blue',
          fontSize: '50px',
        };

        return <div style={divStyle}>Hello World!</div>;
      }
    }


# Props

Передавать данные в компоненты можно с помощью **пропсов** (props). Снаружи пропсы передаются *как атрибуты в HTML*, которые внутри компонента доступны из объекта `props`. Встроенные компоненты точно так же принимают на вход пропсы (например, `className` и другие).

    class HelloMessage extends React.Component {
        render() {
            return <div>Hello {this.props.name}</div>;
        }
    }
    
    const vdom = (
      <div className="row">
        <div className="col">
          <HelloMessage name="Kate" />
        </div>
      </div>
    );

Главное, что нужно запомнить при работе с пропсами: **их нельзя изменять**. Во-первых, из-за принципа работы React это просто ни к чему не приведёт, во-вторых, для работы с изменяемым состоянием в React предусмотрен совершенно другой механизм.

Работая с пропсами, нередко приходится передавать множество параметров, либо эти параметры присутствуют в коде в виде объекта. В таком случае можно упростить передачу, используя оператор расширения.

    const params = {
      className: 'row',
      title: 'name',
    };
    const name = 'Eva';
    const vdom = <div id="container" {...params}>
      Hello, {name}
    </div>;
    
В React предусмотрен способ устанавливать значения пропсов по умолчанию. Пример:

    class Header extends React.Component {
      static defaultProps = {
        text: 'Hello, world!',
      };
    
      render() {
        return (
          <h1>{this.props.text}</h1>
        );
      }
    }

В работе *с коллекциями элементов* в JSX по большей части нет ничего особенного.   
Для повышения эффективности, React настоятельно рекомендует идентифицировать каждую генерируемую строку коллекции. *Генерируя коллекцию элементов в JSX, нужно обязательно проставлять уникальный проп `key`*, который не меняется при повторной генерации коллекции. Если не указать `key` в коллекции, то React начнёт выбрасывать предупреждения об этом в консоль браузера. Кстати, `key` не обрабатывается как обычный проп и его нельзя получить внутри компонента как `this.props.key`.

    class List extends React.Component {
      render() {
        const { data } = this.props
        return (
          <ul>
            {data.map((item) => <li key={item.id}>{item.name}</li>)}
          </ul>
        );
      }
    }

    const items = [
      { id: 'first-item', name: 'first' },
      { id: 'second-item', name: 'second' }
    ];

    ReactDOM.render(
      <List data={items} />,
      document.getElementById('react-root'),
    );

Раньше это было не так, но сейчас допустимо из компонента возвращать массив компонентов. React сам правильно вставит их в DOM:

    class List extends React.Component {
      render() {
        const { data } = this.props;
        const f = (item) => <div key={item.id}>{item.name}</div>;
        return data.map(f);
      }
    }

Для *ручного формирования массива компонентов из корневого компонента*, в React ввели специальный компонент `<React.Fragment>`, которым *можно оборачивать любую коллекцию элементов*. Его особенность в том, что этот элемент никак не отражается в реальном DOM, а существует только на уровне JSX.

    class Article extends React.Component {
      render() {
        const { header, body } = this.props;
        return (
          <React.Fragment>
            <h1>{header}</h1>
            <div>{body}</div>
          </React.Fragment>
        );
      }
    }

У `<React.Fragment>` есть короткая версия `<>`.

    return (
      <>
        <h1>{header}</h1>
        <div>{body}</div>
      </>
    );
    
## Пропс children. React.Children. Вложенные компоненты.

Мы можем оперировать иерархическими структурами при помощи пропса `children`.

    class Alert extends React.Component {
      render() {
        const { children } = this.props;
        return (<div className="alert alert-primary">
          {children}
        </div>);
      }
    }
    
    const vdom = <Alert>
      <p>Message text 1</p>
      <hr />
      <p class="mb-0">Message text 2</p>
    </Alert>;
    
Теперь компонент в JSX пишется в парном теге `<Alert> </Alert>`. Все, что находится между открывающим и закрывающим тегом, попадает внутрь пропса children.
**Но**: *тип у `children` зависит от содержимого*! В случае, когда тег используется как одиночный (<div />), свойство будет равно `undefined`. Если этим содержимым является строка, то именно она окажется внутри `children`, правда, после некоторой обработки: JSX удаляет пробельные символы с начала и конца строки, переносы строки. Любой одиночный дочерний компонент также будет представлен сам собой в `children`. Во всех остальных случаях `children` будет содержать массив. Особенно опасно использовать `children.length`, т.к. в зависимости от типа результат будет *длина строки* или *длина массива вложеных элементов*.

React предоставляет набор функций, предназначенных для манипулирования пропсом `children`. Все они доступны в **React.Children**.

  * React.Children.count

        class ChildrenCounter extends React.Component {
          render() {
            const { children } = this.props
            return <p>Count: {React.Children.count(children)}</p>
          }
        }

  * React.Children.map
  
        class IgnoreFirstChild extends React.Component {
          render() {
            const { children } = this.props;
            return (<div>
                {React.Children.map(children, (child, i) => {
                  // Ignore the first child
                  if (i < 1) return
                  return child
                })}
              </div>);
          }
        }

Кроме перечисленного выше, бывает необходимо обработать дочерние элементы перед выводом, изменив часть в пропсе. Конечно же, напрямую этого сделать нельзя, ведь *пропсы неизменяемы*. Такого поведения можно добиться, клонируя элементы функцией **React.cloneElement**.

## Пакет classnames

Для управления набором классов для компонента, React рекомендует использовать пакет `classnames`. Принцип его работы прост: вместо манипулирования строчкой напрямую, нужно сформировать правильный объект, который уже будет преобразован в строку.

    import cn from 'classnames'
    
    class Button extends React.Component {
      render () {
        const { isPressed, isHovered, label } = this.props;
        const buttonType = 'primary';
        const btnClass = cn({
          btn: true,
          'btn-pressed': isPressed,
          'btn-over': !isPressed && isHovered,
          [`btn-${buttonType}`]: true,
        });
        return <button className={btnClass}>{label}</button>;
      }
    };
    
## Функциональные компоненты

Для создания компонентов React не обязательно использовать классы.

    const List = (props) => {
      return (<ul>
        {props.items.map(v => <li>{v}</li>)}
      </ul>);
    }

    ReactDOM.render(
      <List items={[1, 2, 3]} />,
      document.getElementById('react-root'),
    );

Компоненты, созданные как функции, называются **функциональными**. Они принимают объект со свойствами как первый аргумент, и также начинаются с большой буквы.
На вопрос "когда их стоит использовать?" ответ очень простой. Всегда, *когда компонент не хранит в себе состояние*. Другими словами, большинство компонентов в проекте должно быть именно функциональными.
    
# События и состояния

Компоненты, приведенные выше, были `stateless`, то есть не содержали никакого состояния и могли только отрисовывать переданные свойства. Компоненты также могут быть `stateful`, то есть сохранять внутри себя состояние и обрабатывать его изменения.

  1. Внутри компонента, в конструкторе, определяется начальное состояние, с которым будет инициализирован компонент после отрисовки. Единственное требование к состоянию, которое предъявляет React - тип данных: он должен быть объектом. То, что хранится внутри, определяется самим приложением. Конструктор - единственное место, где `state` может изменяться напрямую (точнее, создаваться). Во всех остальных местах *`this.state` должен использоваться только для чтения*!
  
         class Component extends React.Component {
           constructor(props) {
            super(props); // всегда обязательно
            this.state = { count: 0 };
           }
         }

  1. Функция render использует данные из state для отрисовки.
  
         render() {
           return <button onClick={this.onClick}>
             count: {this.state.count}
           </button>;
         }

  1. На кнопку вешается обработчик. В отличие от HTML, в свойство onClick передается функция и она вызовется автоматически в момент срабатывания события. Внутри обработчика читается текущее значение счетчика, к нему прибавляется единица и далее идет установка нового состояния. Повторюсь: *крайне важно не изменять state напрямую*. *Для установки нового состояния в React предусмотрена функция setState. Именно её вызов приводит к тому, что компонент, в конце концов, перерисуется.* Происходит это не сразу, то есть setState работает асинхронно и внутренняя магия пытается оптимизировать процесс рисования. Важный момент, что *в качестве обработчика должна использоваться стрелочная функция*. Первая причина заключается в том, что обработчики вызываются асинхронно, а методы в классах — это обычные функции с поздним связыванием. Поэтому мы не можем просто так повесить обработчик, так как он потеряет `this`. С таким определением придется постоянно писать подобный код: `onClick={this.onClick.bind(this)}` либо такой `onClick={() => this.onClick()}`. Вторая причина связана с производительностью. Оба предыдущих примера передачи обработчика порождают при каждом вызове функции `render` новые обработчики (так как функции сравниваются по ссылкам, а не по содержимому), а для React это критично. 
  
         onClick = () => {
           const { count } = this.state;
           this.setState({ count: count + 1 });
         };
         
Изменять state в обработчиках только через функцию `setState()`. В параметрах указывается объект с теми значениями стейтов, которые меняются, а те которые не будут указаны - останутся без изменений. `this.setState({ primary: !primary });` 

Еще рекомендация, которую дают разработчики React, это делать структуру стейтов максимально плоской, похожей на то, как мы храним данные в базе данных. Причём желательно в хорошо нормализованном виде. Другими словами, не нужно дублировать данные в состоянии. Пример того как правильно это делать:

    const state = {
      articles: [/*...*/],
      comments: [/*...*/],
    }
    
Один из самых частых вопросов у тех, кто только начинает знакомиться с React, связан с тем, как распределять состояние по компонентам. Короткий ответ: никак. Почти во всех ситуациях разделение состояния усложнит код и работу с ним. Правильный подход — создать корневой компонент, который содержит всё состояние внутри себя, а все нижележащие компоненты получают свои данные как пропсы. В частности, поэтому состояние должно быть максимально плоским, как реляционная база данных. Тогда можно спокойно применять нормализацию и безболезненно выполнять обновления.

Иногда могут возникать ситуации, когда необходимые в глубине свойства приходится протаскивать сквозь множество промежуточных компонентов, которые сами эти пропсы не используют. Это ещё одна причина стараться не увлекаться глубокой вложенностью. С другой стороны, Redux во многом решает эту проблему (и много других). Из этого возникает ещё одна сложность: что, если событие возникает в глубинном компоненте, у которого нет своего состояния? Без использования Redux, по сути, только один выход. Корневой компонент должен пробрасывать *колбеки* во внутренние компоненты, а те, в свою очередь, пробрасывают их дальше по необходимости.

         
## Инициализация состояния компоненты

Предположим, что в компоненте, нужно задать первоначальное значение состояния снаружи, и только в его отсутствие использовать значение по-умолчанию.

  1. Прокидываем через пропс значение (либо не указываем - тогда подразумевается значение по-умолчанию).

         const vdom = <div>
           <Counter count={5} />
           <Counter />
         </div>;

  1. Установить значения по-умолчанию в defaultProps, в конструкторе записать в state проброшенное через пропс значение:
  
         static defaultProps = {
           count: 0,
         };
         
         constructor(props) {
           super(props);
           this.state = { count: this.props.count }
         }

## События

В любой обработчик события при вызове передаётся объект типа SyntheticEvent, кроссбраузерный "враппер" (обёртка) над нативным объектом события. Интерфейсно он не отличается от нативного, кроме того, что работает одинаково во всех браузерах. Все также работает `preventDefault` и `stopPropagation`.

    onClick = (e) => {
      e.preventDefault();
      this.setState({ count: this.state.count + 1 });
    };

React нормализует события так, что они имеют консистентные свойства в различных браузерах. Кроме того, в формах добавляется событие `onChange`, которое ведёт себя в соответствии со своим названием и сильно упрощает работу.

## Формы

В отличие от прямой работы с DOM, в React источником данных является состояние. Формы не являются исключением. Любое изменение в форме, посимвольно, если это ввод, должно быть перенесено в состояние. А элементы форм, чьи данные хранятся в состоянии React, называются управляемые компоненты (controlled components).

    class TextInput extends React.Component {
      constructor(props) {
        super(props);
        this.state = { text: this.props.text };
      }

      handleSubmit = (e) => {
        e.preventDefault();
        alert(`A name was submitted: ${this.state.text}`);
      };

      handleChange = (e) => {
        this.setState({ text: e.target.value });
      };

      render() {
        return <form onSubmit={this.handleSubmit}>
          <input onChange={this.handleChange} value={this.state.text} />
          <input type='submit' value='Submit' />
        </form>;
      }
    }

### `<textarea>`

В HTML значение `<textarea>` устанавливается как его содержимое:

    <textarea>
      Like this
    </textarea>

В React для этого используется атрибут `value`:

    onChange = (e) => {
      this.setState({ text: e.target.value });
    };
    render() {
      return <textarea onChange={this.onChange} value={this.state.text} />;
    }
    
Стоит отметить, что событие `onChange` в React работает так, как ожидается, в отличие от `onChange` в HTML, который срабатывает только когда элемент теряет фокус. Поэтому мы гарантировано получаем срабатывание события на каждое изменение. При этом данные из элемента формы извлекаются обычным способом через `e.target.value`. Ну а дальше всё по старой схеме — данные обновляются в состоянии.

### Выпадающий список

В HTML текущий элемент выбирается с помощью атрибута `selected`, проставленного на нужном `option`. React предлагает другой, более простой и удобный способ. Достаточно проставить атрибут `value` компонента `select` в нужное значение. 

    class FlavorForm extends React.Component {
      constructor(props) {
        super(props);
        this.state = { value: '' };
      }

      handleChange = (e) => {
        this.setState({ value: e.target.value });
      };

      handleSubmit = (e) => {
        e.preventDefault();
        alert(`Your favorite flavor is: ${this.state.value}`);
      };

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Pick your favorite La Croix flavor:
              <select value={this.state.value} onChange={this.handleChange}>
                <option value="grapefruit">Grapefruit</option>
                <option value="lime">Lime</option>
                <option value="coconut">Coconut</option>
                <option value="mango">Mango</option>
              </select>
            </label>
            <input type="submit" value="Submit" />
          </form>
        );
      }
    }
    
### Чекбокс и радиокнопка

Оба этих типа поддерживают атрибут `checked`. Если он выставлен, то элемент отмечается выбранным.

    <input name="isGoing" type="checkbox" checked={this.state.isGoing} onChange={this.handleInputChange} />


# Пространства имён

    <Card>
      <CardBody>
        <CardTitle>Title</CardTitle>
        <b>Body</b>
      </CardBody>
    </Card>

Можно реализовать в виде такой структуры:

    <Card>
      <Card.Body>
        <Card.Title>Title</Card.Title>
        <b>Body</b>
      </Card.Body>
    </Card>

JSX поддерживает механизм пространств имён. Он довольно удобен. Во-первых, достаточно импортировать только компонент верхнего уровня, а остальное доступно уже через него, что довольно логично, если смотреть на JSX как на JS-код. Во-вторых, так лучше задаётся семантика.

Реализуется подобный механизм через статические свойства.

    const Title = (props) => <div className="card-title">{props.children}</div>;
    const Body = (props) => <div className="card-body">{props.children}</div>;

    class Card extends React.Component {
      static Body = Body;
      static Title = Title;

      render() {
        return <div className="card card-block">{this.props.children}</div>;
      }
    }
    
    const vdom = (
      <Card>
        <Card.Body>
          <Card.Title>What is love?</Card.Title>
        </Card.Body>
      </Card>);
