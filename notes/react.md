## create-react-app

Экосистема для старта фронтенд-проектов. Это npm-библиотека, которая позволяет стартануть с нулевой конфигурацией.

    npx create-react-app my-app
    cd my-app/
    npm start

Дальше просто открывайте localhost:3000 и наслаждайтесь.

## babel-preset-react

React расширяет JS и не может работать с Babel без этого пресета.
Не забудьте подключить пресет (preset) babel-preset-react к вашей конфигурации Babel. 
Для `create-react-app` пресет не нужен!

## React Developer Tools

Это расширение для браузера, которое даёт очень удобную панель для анализа происходящего с React в вашем приложении. 

## Импорты

Для работы с React нужно две библиотеки: сам `React` и `ReactDOM`. Причина наличия двух зависимостей достаточно проста. 
Сама библиотека React не связана с DOM напрямую и используется не только в браузере. Поэтому отрисовка конкретно для DOM вынесена в отдельный пакет ReactDOM.

    import React from 'react';
    import ReactDOM from 'react-dom';
    
Важно, чтобы React был импортирован именно как React: `import React from 'react'`.
    
# Компоненты

Центральное понятие в React, единственная сущность, которую он содержит. Вся остальная функциональность построена вокруг компонентов.

    export default class Hello extends React.Component {
      render() {
        return <div>Hello</div>;
      }
    }

  1. Компонент React – это класс, который наследуется от класса `React.Component` (как мы увидим позже, это не единственный способ создать компонент).
  
  1. Функция `render` возвращает то, что будет отрисовано в браузере. Класс-компонент *без функции render существовать не может*, это его интерфейс.
  
  1. Самое поразительное происходит в этой строчке: `return <div>Hello</div>;`. Здравый смысл подсказывает, что такая запись синтаксически невозможна в JS. То, что вы видите, называется **JSX** и является расширением языка (добавляется с помощью Babel). 
  
  1. Экспорт класса по умолчанию задан неспроста. В JS принято создавать один класс на файл. В отличие от обычных классов, *React-компоненты имеют расширение языка JSX*, а значит компонент, определённый выше, должен лежать в файле с именем `Hello.jsx`. Вообще говоря, для всех файлов, которые содержат `JSX`, *принято давать расширение `.jsx`*, независимо от того, создаётся ли компонент в этом файле или нет.

  1. Обратите внимание: класс всё равно проименован. Мы действительно можем его не именовать, но тогда через расширение React Dev Tools будет тяжело понять, что же отрисовал React, так как любой безымянный компонент отображается как `<ReactComponent>`. Поэтому возьмём себе за правило *всегда давать компонентам имена*.

  1. Главное запомнить то, что *в конечном итоге любой React-компонент возвращает кусок DOM* (на самом деле – виртуальный DOM).
  
  1. div – это тоже компонент React, только встроенный. Отличить встроенные компоненты от самописных очень легко. Встроенные всегда начинаются с маленькой буквы, а те, которые не являются частью React, *должны начинаться с большой буквы*.

  1. Созданный компонент сам по себе ничего не делает. Чтобы насладиться результатом его работы, нужно произвести так называемое **монтирование**. То есть указать React, куда его вставить в DOM.
  
         const mountNode = document.getElementById('react-root');
         ReactDOM.render(<Hello />, mountNode);

     Первым параметром передаётся наш компонент *в синтаксисе JSX*, а вторым - реальный узел, любой узел внутри body. Как правило, если у нас не SPA, то React используется в виде виджетов, подключаемых на странице в разных местах. На одной странице может быть несколько виджетов.
  
# JSX

JSX – это похожее на XML-разметку расширение для JavaScript, созданное специально для задач React. React из коробки поставляется с набором компонентов, которые полностью повторяют HTML. По большей части синтаксис и структура JSX и HTML совпадают, но есть некоторые важные различия:

    Так как это похожий на XML синтаксис, одиночные теги в JSX должны быть закрыты: <hr />.
    Вместо атрибута class в JSX используется имя свойства в DOM: className.
    В JSX все свойства DOM и атрибуты (включая обработчики событий) должны быть записаны в camelCase. Исключением являются атрибуты aria- и data-.
    Так как for — зарезервированное слово в JS, в React-элементах используется свойство htmlFor.
    Так как class — зарезервированное слово в JS, в React-элементах используется свойство className.
    Если атрибут передаётся в компонент без значения, то оно автоматически становится равным true.
    Совсем по другому работает атрибут style. Если в HTML это обычная строка, то в JSX только объект.
    Для консистентности с именами атрибутов в HTML, имена CSS-свойств также должны быть записаны в стиле camelCase.

Так же как и в HTML, из компонентов можно строить композиции (в том числе и из других компонентов), например такую:

    const vdom = (
      <div className="card">
        <div className="card-body">
          <h4 className="card-title">Card title</h4>
          <p className="card-text">my text</p>
          <a href="#" className="btn btn-primary">Go somewhere</a>
        </div>
      </div>
    );

И это всё валидный код на JS *с подключённым расширением для JSX*. Нужно помнить, что JSX – расширение языка, а значит это именно код, а не html.
То, что каждый компонент React возвращает кусок DOM, является следствием его фундаментальной идеи и архитектуры.

Внутри JSX можно делать интерполяцию любого JS выражения (не инструкции), в которое также можно вкладывать JSX:

    const name = 'Eva';
    
    const vdom1 = <div>Hello, {name}</div>;
    const vdom2 = <div>Hello, {name.repeat(3)}</div>;

В реальной практике возникают ситуации, когда наличие компонента в DOM зависит от некоторых условий. Например, если в компонент не передали текст, то и не надо выводить соответствующий кусок. Пример:

    const vdom = (
      <div>
        {text ? <h1>{text}</h1> : null}
        <Hello />
      </div>
    );
    
То есть **null** – это допустимое значение, которое рассматривается React как *пустой компонент*. Точно также интерпретируются **false**, **true** и **undefined**. Поэтому пример выше можно переписать ещё короче.

    const vdom = (
      <div>
        {text && <h1>{text}</h1>}
        <Hello />
      </div>
    );

Комментарии JSX не поддерживает напрямую, но их можно эмулировать, используя JavaScript. Для этого достаточно вставить блок кода, внутри которого однострочный JavaScript комментарий:

    {/* A JSX comment */}
    
 Обычный HTML не очень безопасен. Любой текст, который должен оставаться текстом, необходимо экранировать перед выводом. Иначе если внутри содержится HTML, то он будет проинтерпретирован. JSX работает по-другому. Всё, что выводится обычным способом - безопасно по умолчанию и экранируется автоматически. А вот в тех местах, где этого не требуется, экранирование отключается. По сути, для вывода без экранирования нужно использовать свойство *dangerouslySetInnerHTML*.
 
     class Component extends React.Component {
      createMarkup () {
        return { __html: 'First &middot; Second' };
      }

      render() {
        return <div dangerouslySetInnerHTML={this.createMarkup()} />;
      }
    }
    
Стили передаются объектом, имена CSS-свойств должны быть записаны в *camelCase*:

    class Component extends React.Component {
      render() {
        const divStyle = {
          color: 'blue',
          fontSize: '50px',
        };

        return <div style={divStyle}>Hello World!</div>;
      }
    }


# Props

Передавать данные в компоненты можно с помощью **пропсов** (props). Снаружи пропсы передаются *как атрибуты в HTML*, которые внутри компонента доступны из объекта `props`. Встроенные компоненты точно так же принимают на вход пропсы (например, `className` и другие).

    class HelloMessage extends React.Component {
        render() {
            return <div>Hello {this.props.name}</div>;
        }
    }
    
    const vdom = (
      <div className="row">
        <div className="col">
          <HelloMessage name="Kate" />
        </div>
      </div>
    );

Главное, что нужно запомнить при работе с пропсами: **их нельзя изменять**. Во-первых, из-за принципа работы React это просто ни к чему не приведёт, во-вторых, для работы с изменяемым состоянием в React предусмотрен совершенно другой механизм.

Работая с пропсами, нередко приходится передавать множество параметров, либо эти параметры присутствуют в коде в виде объекта. В таком случае можно упростить передачу, используя оператор расширения.

    const params = {
      className: 'row',
      title: 'name',
    };
    const name = 'Eva';
    const vdom = <div id="container" {...params}>
      Hello, {name}
    </div>;
    
В React предусмотрен способ устанавливать значения пропсов по умолчанию. Пример:

    class Header extends React.Component {
      static defaultProps = {
        text: 'Hello, world!',
      };
    
      render() {
        return (
          <h1>{this.props.text}</h1>
        );
      }
    }

В работе *с коллекциями элементов* в JSX по большей части нет ничего особенного.   
Для повышения эффективности, React настоятельно рекомендует идентифицировать каждую генерируемую строку коллекции. *Генерируя коллекцию элементов в JSX, нужно обязательно проставлять уникальный проп `key`*, который не меняется при повторной генерации коллекции. Если не указать `key` в коллекции, то React начнёт выбрасывать предупреждения об этом в консоль браузера. Кстати, `key` не обрабатывается как обычный проп и его нельзя получить внутри компонента как `this.props.key`.

    class List extends React.Component {
      render() {
        const { data } = this.props
        return (
          <ul>
            {data.map((item) => <li key={item.id}>{item.name}</li>)}
          </ul>
        );
      }
    }

    const items = [
      { id: 'first-item', name: 'first' },
      { id: 'second-item', name: 'second' }
    ];

    ReactDOM.render(
      <List data={items} />,
      document.getElementById('react-root'),
    );

Раньше это было не так, но сейчас допустимо из компонента возвращать массив компонентов. React сам правильно вставит их в DOM:

    class List extends React.Component {
      render() {
        const { data } = this.props;
        const f = (item) => <div key={item.id}>{item.name}</div>;
        return data.map(f);
      }
    }

Для *ручного формирования массива компонентов из корневого компонента*, в React ввели специальный компонент `<React.Fragment>`, которым *можно оборачивать любую коллекцию элементов*. Его особенность в том, что этот элемент никак не отражается в реальном DOM, а существует только на уровне JSX.

    class Article extends React.Component {
      render() {
        const { header, body } = this.props;
        return (
          <React.Fragment>
            <h1>{header}</h1>
            <div>{body}</div>
          </React.Fragment>
        );
      }
    }

У `<React.Fragment>` есть короткая версия `<>`.

    return (
      <>
        <h1>{header}</h1>
        <div>{body}</div>
      </>
    );
    
