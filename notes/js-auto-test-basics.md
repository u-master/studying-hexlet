По степени изолированности тестируемых частей кода функциональные тесты принято делить на:
* Модульные (Они проверяют работоспособность конкретных программных модулей, например, функций. 
Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе.)
* Интеграционные (Проверить, что модули работают вместе.)
* Системные (Наиболее сложные и максимально эффективные. В случае сайтов — это тестирование через браузер. 
Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. )

При написании тестов нужно ориентироваться на разнообразие входных данных. 
У любой функции есть один или несколько основных сценариев использования и достаточно написать ровно одну проверку, 
которая покрывает этот сценарий. Дальше нужно смотреть на *пограничные случаи* - ситуации, в которых код может 
повести себя по-особенному:
* Работа с пустой строкой
* Обработка `null`
* Деление на ноль (в большинстве языков вызывает ошибку)
* Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. 
Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. 
Но не забывайте, что условные конструкции могут порождать хитрые связи. 
Например, два независимых условных блока порождают 4 возможных сценария.

Комбинация всех возможных вариантов поведения функции называется *цикломатической сложностью*. 
Это число показывает все возможные пути кода внутри функции. 
Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

## Взаимное влияние тестов
Одно из ключевых правил: **тесты не должны влиять друг на друга**. 
Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.
Один тест может создать файл, изменить переменную или записать что-то в базу. 
Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, 
или наоборот — успешно пройти там, где не должны проходить. 
Кроме этого, в такой ситуации вводится неопределённость.
*Тестирование побочных эффектов* имеет свои хитрости и рассматривается отдельно.

## Условные конструкции в тесте
Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. Decompose it!

## Тест вне тестов (jest)
Задача beforeEach — готовить данные и среду для тестирования, 
а задача test — вызывать код, который тестируется, и проводить проверки. 
Не надо, например, запускать тестирование в beforeEach

## Слишком сильная детализация
Вместо одного теста, в котором содержатся все необходимые проверки,
программист создаёт много тестов, в каждом из которых ровно одна проверка. 
Так не надо делать. Однотипные тесты надо группировать.

