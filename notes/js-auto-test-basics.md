По степени изолированности тестируемых частей кода функциональные тесты принято делить на:
* Модульные (Они проверяют работоспособность конкретных программных модулей, например, функций. 
Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе.)
* Интеграционные (Проверить, что модули работают вместе.)
* Системные (Наиболее сложные и максимально эффективные. В случае сайтов — это тестирование через браузер. 
Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. )

При написании тестов нужно ориентироваться на разнообразие входных данных. 
У любой функции есть один или несколько основных сценариев использования и достаточно написать ровно одну проверку, 
которая покрывает этот сценарий. Дальше нужно смотреть на *пограничные случаи* - ситуации, в которых код может 
повести себя по-особенному:
* Работа с пустой строкой
* Обработка `null`
* Деление на ноль (в большинстве языков вызывает ошибку)
* Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. 
Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. 
Но не забывайте, что условные конструкции могут порождать хитрые связи. 
Например, два независимых условных блока порождают 4 возможных сценария.

Комбинация всех возможных вариантов поведения функции называется *цикломатической сложностью*. 
Это число показывает все возможные пути кода внутри функции. 
Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

## Плохие практики

### Взаимное влияние тестов
Одно из ключевых правил: **тесты не должны влиять друг на друга**. 
Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.
Один тест может создать файл, изменить переменную или записать что-то в базу. 
Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, 
или наоборот — успешно пройти там, где не должны проходить. 
Кроме этого, в такой ситуации вводится неопределённость.
*Тестирование побочных эффектов* имеет свои хитрости и рассматривается отдельно.

### Условные конструкции в тесте
Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. Decompose it!

### Тест вне тестов (jest)
Задача beforeEach — готовить данные и среду для тестирования, 
а задача test — вызывать код, который тестируется, и проводить проверки. 
Не надо, например, запускать тестирование в beforeEach

### Слишком сильная детализация
Вместо одного теста, в котором содержатся все необходимые проверки,
программист создаёт много тестов, в каждом из которых ровно одна проверка. 
Так не надо делать. Однотипные тесты, тесты со схожей логикой надо группировать.

### Обнаружена ошибка в коде?
Перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, 
и только затем уже можно починить их.

## Code Coverage (Покрытие кода тестами)

Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). 
Покрытие анализируется тестовыми фреймворками, которые считают отношения строчек задействованых в тестах
ко всем строчкам исходного кода. Например, если в коде есть условная конструкция, и она не проверяется тестами,
это значит, что все строки кода, входящие в неё, не будут покрыты.
Однако, покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях.
Логические ошибки в коде невозможно отследить только покрытием.
Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. 
Как правило это тесты на пограничные случаи.

## Разработка через тестирование (TDD)

TDD - Test-Driven Development - подход, при котором тесты пишутся **до** кода.
В какой момент лучше писать тесты? Вообще, существует три подхода:
* Тесты пишутся после кода
* Тесты пишутся вместе с кодом
* Тесты пишутся до кода

При системном тестировании, например, когда тест имитирует поведение пользователей и выполняет действия
в браузере, тесты пишутся после кода. В тестах более низкого уровня, интеграционных и модульных тестах,
обычно можно выбирать из вариантов описанных выше. Но подход "писать тесты после кода" относится к наименее полезным.

У тестирования до написания кода есть ещё одно мощное преимущество.
Оно заставляет программиста в первую очередь думать о дизайне своего решения, 
о том, как им будут пользоваться (т.е. об интерфейсе).

TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла,
где на каждой итерации пишется тест, который не проходит, затем дописывается код,
удовлетворяющий данному тесту. После этого всё повторяется. Так шаг за шагом строится приложение.

## Непрерывная интеграция (CI)

Хорошие разработчики используют тесты непрерывно во время разработки и обязательно запускают их перед пушем (git push).
Но этого недостаточно. Там где есть люди, там присутствует человеческий фактор и ошибки. 
Поэтому даже несмотря на локальный запуск, тесты должны запускаться автоматически на серверах непрерывной интеграции.

Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения
для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозиторий (и/или pull request). 
За этим следит либо специальный сервер, либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это покрытие тестами и линтер. Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.

Для внедрения непрерывной интеграции есть два пути. Первый, поставить себе на сервер Jenkins или его аналог. 
Этот вариант требует много ручной работы, поддержка сервера. 
Второй путь – воспользоваться сервисом непрерывной интеграции. Таких сервисов десятки, если не сотни. 
Как правило, большинство из них бесплатны для открытых проектов. 
Одним из первых подобных сервисов был https://travis-ci.com. 
Он до сих пор остаётся наиболее популярным, особенно среди проектов на Гитхабе.
