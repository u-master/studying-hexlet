Инициализация:
`git config --global user.name “<Your Name>”`
`git config --global user.email “you@example.com”`

`git init` создает локальный репозиторий - директорию .git, которая содержит все необходимые для работы git файлы

`git clone '<url>'` - клонирует существующий удаленный репозиторий

`git remote add origin <url>` - добавляет удаленный репозиторий к локальному

`git status` можно посмотреть статус репозитория

`git add <путь до файла>` добавление нового файла в индекс репозитория. 

`git add -i` показывает измененные куски файлов и спрашивает, что с ними сделать; можно выбрать, что должно попасть в коммит, а что нет

`git commit -m '<commit message>'` коммит изменений, готовых к фиксации (после операции add) – отправляет их непосредственно в репозиторий

`git pull --rebase` скачивает из удаленного репозитория новые коммиты и добавляет их в локальный репозиторий

`git push` отправляет коммиченные в локальном репозитории изменения на удаленный репозиторий

`git rm <file>` - удаляет указанный файл и добавляет удаление файла в индекс, восстановить можно `git restore <file>`
 
`git restore [--staged] <file>` - восстанавливает изменения файла из репозитория

`git clean -fd` - убрать неотслеживаемые изменения (новый файл/директория, ни разу не индексированные) `-f` – force, `-d` – directory

`git revert <hash>` - сделать коммит обратный указанному (так как делается коммит - нужно будет указать сообщение)

`git reset` - отмена коммита, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать. `git reset --hard HEAD^` - `--hard` - означает полное удаление изменений, `HEAD^` означает "один коммит от последнего коммита", если надо удалить два последних коммита, то написать `HEAD^2`. *Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого кроме вас.
Если коммит был отправлен во внешний репозиторий, то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с вами над проектом.*

`git commit --amend` - добавить изменения в последний коммит (этот флаг приводит к откату коммита (через reset) и выполнению нового коммита с новыми данными)

`git diff <file>` - увидеть изменения относительно индекса. Если файл не указывать - покажет изменения всех файлов рабочей директории.

`git diff --staged <file>` - увидеть изменения индекса относительно репозитория

`git log [-n <amount>]` - список коммитов, можно ограничить количество показанных коммитов

`git log -p` - выводит коммиты с полным диффом. **Мотать вперед `f`, мотать назад `u`**

`git show <hash>` - выводит дифф указанного коммита (можно первые 8 цифр хэша) относительно предыдущему к нему коммиту

`git blame <file>` - если мы не знаем коммита, но нам интересно, кто последним менял конкретную строку в файле

`git grep` - грепать по гиту! `git grep <string>` - поиск строки по файлам проекта; `git grep -i <string>` - без учета регистра; `git grep <string> <hash>` - поиск в указанном коммите, `git grep <string> $(git rev-list --all)` - поиск по всей истории, `rev-list` возвращает список хешей коммитов

`git checkout <hash>` - переключиться на указанный коммит. `git checkout master` - прыгнем в HEAD

`git stash` - прячем файлы; после этой команды пропадут все изменённые файлы независимо от того, добавлены они в индекс или нет.

`git stash pop` - вернуть спрятанные изменения

[Памятка от GitLab](https://about.gitlab.com/images/press/git-cheat-sheet.pdf)

### Pull request

Один из важнейших механизмов GitHub — запрос на включение изменений (pull request; разг. пулреквест). Именно он позволяет легко и непринуждённо вливаться в разработку любых проектов. Допустим, работая с определённой библиотекой, мы заметили ошибку в коде или документации.

Пройдёмся по шагам, которые необходимо выполнить, для исправления этой ошибки. Наша конечная цель в том, чтобы разработчики библиотеки приняли наш код.

##### Клонирование
Первым шагом необходимо создать копию (клон) репозитория в своём аккаунте. Делается это буквально одной кнопкой «Fork» на странице репозитория.

После этого действия в вашем аккаунте окажется репозиторий с таким же именем. GitHub знает, что это копия оригинального репозитория, и помечает его особым образом. Дальше всё как обычно. Мы клонируем репозиторий на компьютере и производим необходимые изменения. Хорошей практикой считается делать изменения в отдельной ветке (обычно созданной от ветки master).

##### Запрос на включение изменений кода
После того, как изменения залиты на GitHub, в его интерфейсе произойдут изменения. На странице склонированного репозитория появится кнопка «pull request». Если её нажать, то откроется страница, на которой можно указать название пулреквеста и его описание. После отправки пулреквеста в исходном (оригинальном) репозитории на странице «Pull requests» отобразится ваш запрос. Теперь остаётся ждать, когда разработчики библиотеки либо его примут, либо отклонят, либо зададут уточняющие вопросы (тогда с пулреквестом, возможно, потребуется ещё поработать).

##### Исправления прямо на Гитхабе
В более простых ситуациях, когда достаточно исправить текст или опечатку, Github позволяет сделать пулреквест прямо из своего интерфейса. Для этого достаточно открыть любой файл проекта и нажать на иконку редактирования. После завершения редактирования Github сам предложит создать пулреквест с этим изменением.
